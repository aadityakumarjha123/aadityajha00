<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Glowing Heart Animation</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
  // ------------------------------------
  // CREATE SCENE & CAMERA
  // ------------------------------------
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.z = 50;

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // ------------------------------------
  // HEART PATH FUNCTION
  // ------------------------------------
  function createHeartPath(particleIndex, totalParticles) {
    const t = (particleIndex / totalParticles) * Math.PI * 2;
    const scale = 2.2;

    let x = 16 * Math.pow(Math.sin(t), 3);
    let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t)
          - 2 * Math.cos(3 * t) - Math.cos(4 * t);

    const finalX = x * scale;
    const finalY = y * scale;
    const z = Math.sin(t * 4) * 2;

    const jitterStrength = 0.2;

    return new THREE.Vector3(
      finalX + (Math.random() - 0.5) * jitterStrength,
      finalY + (Math.random() - 0.5) * jitterStrength,
      z + (Math.random() - 0.5) * jitterStrength
    );
  }

  // ------------------------------------
  // CREATE PARTICLES
  // ------------------------------------
  const totalParticles = 2000;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(totalParticles * 3);

  for (let i = 0; i < totalParticles; i++) {
    const pos = createHeartPath(i, totalParticles);
    positions[i * 3] = pos.x;
    positions[i * 3 + 1] = pos.y;
    positions[i * 3 + 2] = pos.z;
  }

  geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

  const material = new THREE.PointsMaterial({
    size: 0.2,
    color: 0x00ffcc,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending
  });

  const particleSystem = new THREE.Points(geometry, material);
  scene.add(particleSystem);

  // ------------------------------------
  // ANIMATION LOOP
  // ------------------------------------
  function animate() {
    requestAnimationFrame(animate);
    particleSystem.rotation.y += 0.002;
    particleSystem.rotation.x += 0.001;
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
